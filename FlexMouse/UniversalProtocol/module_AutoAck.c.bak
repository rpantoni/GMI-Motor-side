/**
  ********************************************************************************************************************************
  * @file    module_AutoAck.c 
  * @author  Pamela Lee
  * @version V1.0
  * @date    21-OCT-2020
  * @brief   Main driver module for Auto Acknowledgement of Universal procotol.
  * @details 
  ********************************************************************************************************************************
  */

/* Includes --------------------------------------------------------------------------------------------------------------------*/
#include "module_AutoAck.h"

//#include "driver_usart2.h"

/* Content ---------------------------------------------------------------------------------------------------------------------*/
/* Auto acknowledgement handle declaration */
extern ProcessInfo processInfoTable[];
/*
extern void Delay(__IO uint32_t nTime);

extern Ram_Buf sharedMemArray[STRUCT_MEM_ARRAY_SIZE];

extern Ram_Buf *usart2StructMem_u32;

//Usart2_Control* usart2_Module_Control;
unsigned char* RxCMD ;
extern uint8_t usart2CaptureLen;
extern uint8_t UniProtocolState;
extern __IO uint8_t indexTx;

extern Usart2_Control *usart2Control;
*/
uint8_t FrameAckID = 0;
  
//*****************************************************************************************
typedef  struct 
{
    uint8_t       AckCmd;
    uint16_t      E_AckCmd;
    uint8_t       ProcessAckID;                                          //Ack process ID
    uint8_t       FrameAckID;                                            //
}UniversalAckInfo;
#define AckBufSize 16
UniversalAckInfo buf[AckBufSize];//= { {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0} };
uint8_t Uni_AckHead = 0;
uint8_t Uni_AckTail = 0;
uint8_t Uni_NextFrameID = 0;                    //Unversal Ack frame ID (which the number continue count up and roll over) 
//********************************************************************************************************************************************************

enum {
  INIT_MODULE,
  RUN_MODULE,
  // additional states to be added here as necessary.
  IRQ_MODULE = DEFAULT_IRQ_STATE,
  KILL_MODULE = KILL_APP
};




uint8_t moduleAutoAck_u32(uint8_t drv_id_u8, uint8_t prev_state_u8, uint8_t next_state_u8, uint8_t irq_id_u8) {
  uint8_t return_state_u8 = INIT_MODULE;
  switch (next_state_u8) {
    case INIT_MODULE: {
      // Initialize Auto Ackledgement ring 
      UniversalAckInit();
      return_state_u8 = RUN_MODULE;
      break;
    }
    case RUN_MODULE: {

      return_state_u8 = RUN_MODULE;
      break;
    }
    case KILL_MODULE: {
      // The USART2 driver module must only be executed once.
      // Setting processStatus_u8 to PROCESS_STATUS_KILLED prevents the scheduler main loop from calling this module again.
      uint8_t table_index_u8 = getProcessInfoIndex(drv_id_u8);
      if (table_index_u8 != INDEX_NOT_FOUND) {
        processInfoTable[table_index_u8].Sched_DrvData.processStatus_u8 = PROCESS_STATUS_KILLED;
      }
      return_state_u8 = KILL_MODULE;
      break;
    }
    default: {
      return_state_u8 = KILL_MODULE;
      break;
    }
  }
  return return_state_u8;
}

void UniversalAckInit(void)
{
  for(uint8_t index = 0; index < AckBufSize ; index++)
  {
    buf[index].AckCmd = 0;
    buf[index].E_AckCmd = 0;
    buf[index].FrameAckID = 0;
    buf[index].ProcessAckID = 0;
  }  
  Uni_AckHead = 0;
  Uni_AckTail = 0;
  Uni_NextFrameID = 0;
}

uint8_t AckDatSet(uint8_t _AckCmd, uint16_t _E_AckCmd, uint8_t _FrameAckID, uint8_t _ProcessAckID)
{
    if(++Uni_AckTail == AckBufSize) {
      Uni_AckTail = 0;
    }
    buf[Uni_AckTail].AckCmd = _AckCmd;
    buf[Uni_AckTail].E_AckCmd = _E_AckCmd;
    buf[Uni_AckTail].FrameAckID = _FrameAckID;
    buf[Uni_AckTail].ProcessAckID = _ProcessAckID;
    Uni_NextFrameID++;
    return true;
}

uint8_t IsAckBufFull(void) 
{
  int16_t result = (int16_t)Uni_AckHead - (int16_t)Uni_AckTail;
  if( (result == (AckBufSize-1)) || (result == 1)) 
  { 
    return (true);
  }  
  return (false);
}

uint8_t UniversalAckTimeOut()
{
  
  return(true);
}